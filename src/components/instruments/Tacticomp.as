package components.instruments {import com.common.LLNAngle;import com.dynamicInstruments.DynamicSprite;import com.inAppPurchase.CommonStore;import com.polar.BestVmg;import com.polar.PolarContainer;import com.polar.PolarTable;import com.sailing.ForgatHandler;import com.sailing.SailData;import com.sailing.instruments.BaseInstrument;import com.sailing.Splitter;import com.sailing.units.Unit;import com.utils.Assets;import com.utils.Blinker;import flash.geom.Rectangle;import starling.core.Starling;import starling.display.Image;import starling.events.Event;import starling.events.TouchEvent;import starling.text.TextField;import starling.textures.Texture;import starling.textures.TextureSmoothing;import starling.utils.HAlign;import starling.utils.VAlign;import starling.utils.deg2rad;public class Tacticomp extends BaseInstrument {    private var _datas:SailData;    public var actualState:String = "";    private var forgatHandler:ForgatHandler;    private var forgatHandler1:ForgatHandler;    private var forgatHandler2:ForgatHandler;    private var forgatHandler2b:ForgatHandler;    private var forgatHandler3:ForgatHandler;    private var forgatHandler3a:ForgatHandler;    private var forgatHandler3b:ForgatHandler;    private var forgatHandler4:ForgatHandler;    private var forgatHandler5:ForgatHandler;    private var LLN_angle:Number = 0;    private var _isMwvt:Boolean;    private var _vmg:BestVmg;    private var _llnIsUp:Boolean = true;    private var _needTween:Boolean;    private var _rudderWidth:Number;    private var _rudder_barWidth:Number;    private var _previousRsa:Number;    private var _isCogVisible:Boolean = false;    private var _isCurrentVisible:Boolean = false;    private var _isBwcVisible:Boolean = false;    private var compass:Image;    private var twind:Image;    private var cog:DynamicSprite;    private var cog2:Image;    private var LLN:DynamicSprite;    private var WPT:DynamicSprite;    private var current:Image;    private var left_mask:DynamicSprite;    private var right_mask:DynamicSprite;    private var piros:Image;    private var zold:Image;    private var rudder_bar:Image;    private var minus_btn:Image;    private var plus_btn:Image;    private var btn_rec:Image;    private var help_over:Image;    private var help_btn:Image;    private var angle:TextField;    private var port:TextField;    private var starboard:TextField;    private var rudder:TextField;    public function Tacticomp() {        super(Assets.getInstrument("tacticomp"));        forgatHandler = new ForgatHandler(compass, this);        forgatHandler1 = new ForgatHandler(twind, this);        forgatHandler2 = new ForgatHandler(cog, this);        forgatHandler2b = new ForgatHandler(cog2, this);        forgatHandler3 = new ForgatHandler(LLN, this);        forgatHandler4 = new ForgatHandler(WPT, this);        forgatHandler5 = new ForgatHandler(current, this);        forgatHandler3a = new ForgatHandler(zold, this);        forgatHandler3b = new ForgatHandler(piros, this);        compass.visible = false;        twind.visible = false;        cog.visible = false;        current.visible = false;        piros.visible = false;        zold.visible = false;        minus_btn.addEventListener(TouchEvent.TOUCH, minusButtonHandler);        plus_btn.addEventListener(TouchEvent.TOUCH, plusButtonHandler);        btn_rec.addEventListener(TouchEvent.TOUCH, autoButtonHandler);        angle.addEventListener(TouchEvent.TOUCH, autoButtonHandler);        help_over.visible = false;        help_btn.addEventListener(TouchEvent.TOUCH, helpButtonHandler);        help_over.addEventListener(TouchEvent.TOUCH, helpButtonHandler);//        help_label.addEventListener(TouchEvent.TOUCH, helpButtonHandler);        LLNAngle.instance.addEventListener("llnUpAngleChange", llnAngleChangeHandler);        LLNAngle.instance.addEventListener("llnDownAngleChange", llnAngleChangeHandler);        LLNAngle.instance.addEventListener("llnTypeChange", llnTypeChangeHandler);        setBwcInvalid();        setMwvtInvalid();        setRsaInvalid();        unitChanged();    }    protected override function buildComponents():void {        var tacticomp:Texture = Assets.getAtlas("tacticomp");        compass = _instrumentAtlas.getComponentAsImage(tacticomp, "compass");        twind = _instrumentAtlas.getComponentAsImage(tacticomp, "twind");        cog = _instrumentAtlas.getComponentAsDynamicSprite(tacticomp, "cog", false, false);        _instrumentAtlas.getComponentAsImageWithParent(tacticomp, "cog.instance14", cog);        cog2 = _instrumentAtlas.getComponentAsImageWithParent(tacticomp, "cog.cog2", cog);        WPT = _instrumentAtlas.getTextFieldComponent(tacticomp, "WPT", VAlign.CENTER,HAlign.CENTER);        WPT["waypointname"].height *= 1.5;        WPT["waypointname"].autoScale = true;        current = _instrumentAtlas.getComponentAsImage(tacticomp, "current", true);        current.pivotY *= 1.07;        LLN = _instrumentAtlas.getComponentAsDynamicSprite(tacticomp, "LLN", false, false);        _instrumentAtlas.getComponentAsImageWithParent(tacticomp, "LLN.LLN1", LLN);        _instrumentAtlas.getComponentAsImageWithParent(tacticomp, "LLN.LLN2", LLN);        right_mask = _instrumentAtlas.getComponentAsDynamicSprite(tacticomp, "instance2");        right_mask.clipRect = new Rectangle(right_mask.width/2,0, right_mask.width/2,right_mask.height);        zold = _instrumentAtlas.getComponentAsImageWithParent(tacticomp, "zold", right_mask, true);        left_mask = _instrumentAtlas.getComponentAsDynamicSprite(tacticomp, "instance2");        left_mask.clipRect = new Rectangle(0,0, left_mask.width/2,left_mask.height);        piros = _instrumentAtlas.getComponentAsImageWithParent(tacticomp, "piros", left_mask, true);        piros.x = zold.x;        piros.pivotX = piros.pivotY;        minus_btn = _instrumentAtlas.getComponentAsImage(tacticomp, "minus_btn");        plus_btn = _instrumentAtlas.getComponentAsImage(tacticomp, "plus_btn");        btn_rec = _instrumentAtlas.getComponentAsImage(tacticomp, "btn_rec");        btn_rec.y -= 1;        help_btn = _instrumentAtlas.getComponentAsImage(tacticomp, "help_btn");        help_over = _instrumentAtlas.getComponentAsImage(tacticomp, "help_over", true);//        help_label = _instrumentAtlas.getComponentAsTextField("help_label", VAlign.CENTER,HAlign.CENTER, 1.1);        angle = _instrumentAtlas.getComponentAsTextField("angle", VAlign.CENTER,HAlign.CENTER);        angle.x += 1;        port = _instrumentAtlas.getComponentAsTextField("port", VAlign.CENTER,HAlign.RIGHT);        starboard = _instrumentAtlas.getComponentAsTextField("starboard", VAlign.CENTER,HAlign.RIGHT);        rudder = _instrumentAtlas.getComponentAsTextField("rudder", VAlign.CENTER,HAlign.RIGHT);        rudder_bar = _instrumentAtlas.getComponentAsImage(tacticomp, "rudder_bar");        rudder_bar.smoothing = TextureSmoothing.NONE;        _rudder_barWidth = rudder_bar.width;//        this.addChild(_instrumentAtlas.getComponentAsImage("instance3"));        this.addChild(right_mask);        this.addChild(left_mask);        this.addChild(compass);        this.addChild(LLN);        this.addChild(twind);        this.addChild(WPT);        this.addChild(cog);//        var rudderBackground:Image = _instrumentAtlas.getComponentAsImage(tacticomp, "instance9");//        _rudderWidth = rudderBackground.width/2;        this.addChild(_instrumentAtlas.getComponentAsImage(tacticomp, "instance9"));        _rudderWidth = this.getChildAt(this.numChildren-1).width/2;        this.addChild(rudder_bar);        this.addChild(_instrumentAtlas.getComponentAsImage(tacticomp, "instance11"));        this.addChild(_instrumentAtlas.getComponentAsImage(tacticomp, "instance12"));        this.addChild(current);        this.addChild(minus_btn);        this.addChild(plus_btn);        this.addChild(btn_rec);        this.addChild(angle);        this.addChild(port);        this.addChild(starboard);        this.addChild(rudder);        this.addChild(_instrumentAtlas.getComponentAsImage(tacticomp, "instance18"));        this.addChild(help_btn);        this.addChild(help_over);//        this.addChild(help_label);    }    public override function updateState(stateType:String):void {    }    public override function updateDatas(datas:SailData, needTween:Boolean = true):void {        _datas = datas;        _needTween = needTween;        var isVhw:Boolean = datas!=null && datas.heading.isValid();        var isPAS:Boolean = datas!=null && datas.positionandspeed.isValid();        var isSAD:Boolean = datas!=null && datas.setanddrift.isValid();        var isBwc:Boolean = datas!=null && datas.bwc.isValid();        var isMwvr:Boolean = datas!=null && datas.apparentwind.isValid();        var isRsa:Boolean = datas!=null && datas.rsa.isValid();        _isMwvt = datas!=null && datas.truewindc.isValid();        if (isVhw) {            Blinker.removeObject(compass);            compass.visible = true;            forgatHandler.forgat(0 - datas.heading.heading.value, { needTween: _needTween });        }        if (isVhw && isPAS) {            if (datas.positionandspeed.cog.value != Unit.INVALID_VALUE) {                Blinker.removeObject(cog);                cog.visible = true;                _isCogVisible = true;                forgatHandler2.forgat(datas.positionandspeed.cog.value - datas.heading.heading.value, { needTween: _needTween });                forgatHandler2b.forgat(0 - (0 - datas.heading.heading.value + datas.positionandspeed.cog.value), { needTween: _needTween });//                cog2.rotation = 0 - (0 - datas.heading.heading.value + datas.positionandspeed.cog.value);            } else {                cog.visible = false;            }        }        if (isVhw && isSAD) {            Blinker.removeObject(current);            current.visible = true;            _isCurrentVisible = true;            forgatHandler5.forgat(datas.setanddrift.angleset.getPureData() - datas.heading.heading.value, { needTween: _needTween });        }        if (isBwc && isVhw) {            removeBwcBlinker();            WPT.visible = true;            _isBwcVisible = true;            WPT["waypointname"].text = datas.bwc.waypointId;            forgatHandler4.forgat(datas.bwc.waypointBearing.value - datas.heading.heading.value, { needTween: _needTween });        }        if (_isMwvt) {            setMwvtValid();            LLN.visible = !(!PolarContainer.instance.polarTableFromFile.hasPolarForWind(_datas.truewindc.windSpeed.getPureData()) && LLNAngle.instance.llnType == LLNAngle.LLN_AUTO);            setAutoLLN(LLNAngle.instance.llnType == LLNAngle.LLN_AUTO);            if (LLN.visible) {                rotateLLN();                forgatHandler3.forgat(datas.truewindc.windDirection.value, { needTween: _needTween });            }            setLLNText();            forgatHandler1.forgat(datas.truewindc.windDirection.value, { needTween: _needTween });        }        if (isMwvr) {            setMwvrValid();            if (datas.apparentwind.windDirection.value < 180) {                forgatHandler3a.forgat(datas.apparentwind.windDirection.value - 180, { needTween: _needTween });                piros.visible = false;                zold.visible = true;            } else {                forgatHandler3b.forgat(datas.apparentwind.windDirection.value - 180, { needTween: _needTween });                piros.visible = true;                zold.visible = false;            }        }        if (isRsa) {            removeRsaBlinker();            var rsa:Number = datas.rsa.rudderSensorStarboard;            rudder_bar.visible = (rsa!=0);            if(rsa!=_previousRsa) {                rudder.text = Splitter.withValue(rsa).a3;                if (rsa < -44) {                    if (_needTween) {                        Starling.juggler.tween(rudder_bar, 0.5, {                            scaleX: -(_rudderWidth/_rudder_barWidth)                        });                    } else {                        rudder_bar.scaleX = -(_rudderWidth/_rudder_barWidth);                    }                } else if (rsa > 44) {                    if (_needTween) {                        Starling.juggler.tween(rudder_bar, 0.5, {                            scaleX: (_rudderWidth/_rudder_barWidth)                        });                    } else {                        rudder_bar.scaleX = (_rudderWidth/_rudder_barWidth);                    }                } else {                    if (_needTween) {                        Starling.juggler.tween(rudder_bar, 0.5, {//                            width: ((rsa + ((rsa < 0) ? -3 : 3)) / 47) * _rudderWidth                            scaleX: (((rsa + ((rsa < 0) ? -3 : 3)) / 47) * _rudderWidth)/_rudder_barWidth                        });                    } else {//                        rudder_bar.scaleX = ((rsa + ((rsa < 0) ? -3 : 3)) / 47) * _rudderWidth;                        rudder_bar.scaleX = (((rsa + ((rsa < 0) ? -3 : 3)) / 47) * _rudderWidth)/_rudder_barWidth;                    }                }                _previousRsa = rsa;            }        }    }    public override function dataInvalidated(key:String):void {        if (key === "heading") {            removeVhwBlinker();            compass.visible = false;            cog.visible = false;            current.visible = false;            removeBwcBlinker();            setBwcInvalid();            _isCogVisible = false;            _isCurrentVisible = false;            _isBwcVisible = false;        }        if (key === "truewindc") {            removeMwvtBlinker();            Blinker.removeObject(LLN["LLN1"]);            Blinker.removeObject(LLN["LLN2"]);            setMwvtInvalid();        }        if (key === "apparentwind") {            removeMwvrBlinker();            piros.visible = false;            zold.visible = false;        }        if (key === "positionandspeed") {            Blinker.removeObject(cog);            cog.visible = false;            _isCogVisible = false;        }        if (key === "bwc") {            removeBwcBlinker();            setBwcInvalid();            _isBwcVisible = false;        }        if (key === "setanddrift") {            Blinker.removeObject(current);            current.visible = false;            _isCurrentVisible = false;        }        if (key === "rsa") {            removeRsaBlinker();            setRsaInvalid();        }    }    public override function dataPreInvalidated(key:String):void {        if (key === "heading") {            Blinker.addObject(compass);            if (_isCogVisible) {                Blinker.addObject(cog);                _isCogVisible = false;            }            if (_isCurrentVisible) {                Blinker.addObject(current);                _isCurrentVisible = false;            }            if (_isBwcVisible) {                Blinker.addObject(WPT);                Blinker.addObject(WPT["waypointname"]);                _isBwcVisible = false;            }        }        if (key === "truewindc") {            Blinker.addObject(twind);            Blinker.addObject(LLN);            Blinker.removeObject(LLN["LLN1"]);            Blinker.removeObject(LLN["LLN2"]);            Blinker.addObject(port);            Blinker.addObject(starboard);        }        if (key === "apparentwind") {            if(piros.visible) {                Blinker.addObject(piros);            } else if(zold.visible) {                Blinker.addObject(zold);            }        }        if (key === "positionandspeed" && _isCogVisible) {            Blinker.addObject(cog);            _isCogVisible = false;        }        if (key === "bwc" && _isBwcVisible) {            Blinker.addObject(WPT);            Blinker.addObject(WPT["waypointname"]);            _isBwcVisible = false;        }        if (key === "setanddrift" && _isCurrentVisible) {            Blinker.addObject(current);            _isCurrentVisible = false;        }        if (key === "rsa") {            Blinker.addObject(rudder);            Blinker.addObject(rudder_bar);        }    }    private function setBwcInvalid():void {        WPT.visible = false;        WPT["waypointname"].text = "";    }    private function setMwvtInvalid():void {        angle.text = "";        LLN.visible = false;        twind.visible = false;        port.text = "---";        starboard.text = "---";        LLN_angle = LLNAngle.instance.llnUpAngle;        _isMwvt = false;//        minus_btn.enabled = false;//        plus_btn.enabled = false;    }    private function setRsaInvalid():void {        rudder.text = " --";        Starling.juggler.removeTweens(rudder_bar);        rudder_bar.visible = false;        _previousRsa = Number.MIN_VALUE;    }    private function setMwvtValid():void {        removeMwvtBlinker();        angle.text = (LLNAngle.instance.llnType == LLNAngle.LLN_MANUAL) ? "M" : "A";//        angle.text = LLN_angle.toString();        twind.visible = true;        LLN.visible = true;//        minus_btn.enabled = true;//        plus_btn.enabled = true;    }    private function setMwvrValid():void {        removeMwvrBlinker();    }    private function removeBwcBlinker():void {        Blinker.removeObject(WPT);        Blinker.removeObject(WPT["waypointname"]);    }    private function removeVhwBlinker():void {        Blinker.removeObject(compass);        Blinker.removeObject(cog);        Blinker.removeObject(current);    }    private function removeMwvtBlinker():void {        Blinker.removeObject(twind);        Blinker.removeObject(LLN);        Blinker.removeObject(angle);        Blinker.removeObject(port);        Blinker.removeObject(starboard);    }    private function removeMwvrBlinker():void {        Blinker.removeObject(piros);        Blinker.removeObject(zold);    }    private function removeRsaBlinker():void {        Blinker.removeObject(rudder);        Blinker.removeObject(rudder_bar);    }    private function minusButtonHandler(event:TouchEvent):void {        if(touchIsEnd(event)) {            if (_isMwvt && ((_llnIsUp && LLN_angle > LLNAngle.LLN_UP_MIN_LIMIT) || (!_llnIsUp && LLN_angle > LLNAngle.LLN_DOWN_MIN_LIMIT))) {                LLN_angle--;                if (_llnIsUp) {                    LLNAngle.instance.llnUpAngle = LLN_angle;                } else {                    LLNAngle.instance.llnDownAngle = LLN_angle;                }                if (LLNAngle.instance.llnType == LLNAngle.LLN_AUTO) {                    LLNAngle.instance.llnType = LLNAngle.LLN_MANUAL;                    angle.text = "M";                }//                angle.text = LLN_angle.toString();            }        }    }    private function plusButtonHandler(event:TouchEvent):void {        if(touchIsEnd(event)) {            if (_isMwvt) {                if (LLN_angle < LLNAngle.LLN_MAX_LIMIT) {                    LLN_angle++;                    if (_llnIsUp) {                        LLNAngle.instance.llnUpAngle = LLN_angle;                    } else {                        LLNAngle.instance.llnDownAngle = LLN_angle;                    }                    if (LLNAngle.instance.llnType == LLNAngle.LLN_AUTO) {                        LLNAngle.instance.llnType = LLNAngle.LLN_MANUAL;                        angle.text = "M";                    }//                    angle.text = LLN_angle.toString();                }            }        }    }    private function autoButtonHandler(event:TouchEvent):void {        if(touchIsEnd(event)) {            if (_isMwvt) {                if (LLNAngle.instance.llnType == LLNAngle.LLN_MANUAL && CommonStore.instance.isPolarEnabled) {                    LLNAngle.instance.llnType = LLNAngle.LLN_AUTO;                    angle.text = "A";                } else {                    LLNAngle.instance.llnType = LLNAngle.LLN_MANUAL;                    angle.text = "M";                }            }        }    }    private function setAutoLLN(isAuto:Boolean):void {        var polarTable:PolarTable = PolarContainer.instance.polarTableFromFile;        var windSpeed:Number = Math.round(_datas.truewindc.windSpeed.getPureData());        var windDirection:Number = Math.floor(_datas.truewindc.windDirection.getPureData() / 90);        var hasVmg:Boolean = false;        if (windSpeed >= 0 && windSpeed < PolarTable.MAX_WINDSPEED && polarTable.hasPolarForWind(windSpeed)) {            for (var i:int = 0; i <= 3; i++) {                _vmg = (polarTable.bestVmg[windSpeed] != null) ? polarTable.bestVmg[windSpeed][i] : null;                if (_vmg != null) {                    if (_vmg.angle <= 90 || _vmg.angle > 270) {                        if (i == windDirection) {                            hasVmg = true;                            _llnIsUp = true;                        }                        if (isAuto) {                            LLNAngle.instance.llnUpAngle = (_vmg.angle < 180) ? _vmg.angle : (360 - _vmg.angle);                        }                    } else if (_vmg.angle > 90 && _vmg.angle <= 270) {                        if (i == windDirection) {                            hasVmg = true;                            _llnIsUp = false;                        }                        if (isAuto) {                            LLNAngle.instance.llnDownAngle = Math.abs(180 - _vmg.angle);                        }                    }                }            }            if (isAuto && !hasVmg) {                Blinker.addObject(LLN.LLN1);                Blinker.addObject(LLN.LLN2);            } else {                Blinker.removeObject(LLN.LLN1);                Blinker.removeObject(LLN.LLN2);            }        }        if (!isAuto) {            LLN_angle = (_llnIsUp) ? LLNAngle.instance.llnUpAngle : LLNAngle.instance.llnDownAngle;        }    }    private function setLLN():void {        Starling.juggler.tween(LLN["LLN1"], forgatHandler3.duration, {            rotation: deg2rad(0 - LLN_angle)        });        Starling.juggler.tween(LLN["LLN2"], forgatHandler3.duration, {            rotation: deg2rad(LLN_angle)        });    }    private function setLLNText():void {        if (_datas != null) {            var minusLLN:Number = _datas.heading.heading.value + _datas.truewindc.windDirection.value - LLN_angle;            if(!_llnIsUp) {                minusLLN -= 180;            }            if (minusLLN < 0) {                minusLLN += 360;            } else if (minusLLN > 360) {                minusLLN -= 360;            }            starboard.text = (LLN.visible) ? Splitter.withValue(minusLLN).a03 : "---";            var plusLLN:Number = _datas.heading.heading.value + _datas.truewindc.windDirection.value + LLN_angle;            if(!_llnIsUp) {                plusLLN -= 180;            }            if (plusLLN < 0) {                plusLLN += 360;            } else if (plusLLN > 360) {                plusLLN -= 360;            }            port.text = (LLN.visible) ? Splitter.withValue(plusLLN).a03 : "---";        }    }    private function llnAngleChangeHandler(e:Event):void {        LLN_angle = (_llnIsUp) ? LLNAngle.instance.llnUpAngle : LLNAngle.instance.llnDownAngle;        angle.text = (LLNAngle.instance.llnType == LLNAngle.LLN_MANUAL) ? "M" : "A";//        angle.text = LLN_angle.toString();        if (_isMwvt) {            rotateLLN();            setLLNText();        }    }    private function llnTypeChangeHandler(e:Event):void {        if (_isMwvt) {            LLN.visible = !(!PolarContainer.instance.polarTableFromFile.hasPolarForWind(_datas.truewindc.windSpeed.getPureData()) && LLNAngle.instance.llnType == LLNAngle.LLN_AUTO);            if (LLN.visible) {                rotateLLN();            }            setLLNText();            if (LLNAngle.instance.llnType == LLNAngle.LLN_MANUAL) {                Blinker.removeObject(LLN.LLN1);                Blinker.removeObject(LLN.LLN2);                angle.text = "M";            } else {                setAutoLLN(true);                angle.text = "A";            }        }    }    private function rotateLLN():void {        if (_needTween) {            setLLN();        } else {            LLN["LLN1"].rotation = 0 - LLN_angle;            LLN["LLN2"].rotation = LLN_angle;        }    }    public override function unitChanged():void {    }    private function helpButtonHandler(event:TouchEvent):void {        if(touchIsEnd(event)) {            help_over.visible = !help_over.visible;        }    }}}